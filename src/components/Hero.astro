---
interface Props {
  title: string;
  subtitle?: string;
  height?: 'full' | 'large' | 'medium';
}

const { 
  title, 
  subtitle, 
  height = 'full' 
} = Astro.props;

const heightClass = {
  full: 'h-screen',
  large: 'h-[80vh]',
  medium: 'h-[60vh]'
}[height];
---

<section 
  class={`relative ${heightClass} flex items-center justify-center overflow-hidden hero-section`}
  data-aos="fade-in"
>
  <!-- Background Image with Parallax Effect (loaded dynamically from S3) -->
  <div 
    class="absolute inset-0 bg-cover bg-center parallax-bg bg-slate-900"
    id="hero-background"
  >
    <div class="absolute inset-0 bg-gradient-to-b from-black/60 via-black/40 to-black/80"></div>
  </div>
  
  <!-- Content -->
  <div class="relative z-10 text-center px-6 max-w-5xl mx-auto">
    <h1 
      class="font-serif text-5xl md:text-7xl lg:text-8xl font-bold mb-6 animate-fade-in tracking-tight"
      data-aos="fade-up"
      data-aos-delay="200"
    >
      {title}
    </h1>
    {subtitle && (
      <p 
        class="text-xl md:text-3xl text-white/90 font-light"
        data-aos="fade-up"
        data-aos-delay="400"
      >
        {subtitle}
      </p>
    )}
    <slot />
  </div>
  
  <!-- Scroll Indicator -->
  <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 animate-bounce">
    <svg class="w-6 h-6 text-white/60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
    </svg>
  </div>
</section>

<script>
  let backgrounds: string[] = [];
  let currentIndex = 0;
  let imagesPreloaded = false;
  
  // Fetch and load all backgrounds from S3
  async function loadBackgrounds() {
    try {
      const response = await fetch('/api/background');
      if (!response.ok) {
        console.error('Failed to load backgrounds');
        return;
      }
      
      const data = await response.json();
      
      if (data.backgrounds && data.backgrounds.length > 0) {
        backgrounds = data.backgrounds.map((bg: any) => bg.url);
        
        // Set first background immediately
        setBackground(0);
        
        // Preload remaining images in background for smooth transitions
        if (backgrounds.length > 1) {
          preloadBackgrounds();
          
          // Start rotation after a short delay to allow first image to load
          setTimeout(() => {
            setInterval(rotateBackground, 5000); // Rotate every 5 seconds
          }, 2000);
        }
      }
    } catch (error) {
      console.error('Error loading backgrounds:', error);
    }
  }
  
  // Preload all background images
  function preloadBackgrounds() {
    backgrounds.forEach((url, index) => {
      if (index > 0) { // Skip first one as it's already loading
        const img = new Image();
        img.src = url;
      }
    });
    imagesPreloaded = true;
  }
  
  // Set background with smooth transition
  function setBackground(index: number) {
    const heroBackground = document.getElementById('hero-background');
    if (heroBackground && backgrounds[index]) {
      heroBackground.style.backgroundImage = `url('${backgrounds[index]}')`;
    }
  }
  
  // Rotate to next background
  function rotateBackground() {
    currentIndex = (currentIndex + 1) % backgrounds.length;
    setBackground(currentIndex);
  }
  
  // Load backgrounds when page loads
  loadBackgrounds();
</script>

<style>
  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .animate-fade-in {
    animation: fade-in 1.5s ease-out;
  }
  
  .parallax-bg {
    will-change: transform;
    transition: background-image 0.5s ease-in-out;
    /* Enable parallax only on desktop (768px and above) */
    background-attachment: scroll;
  }
  
  @media (min-width: 768px) {
    .parallax-bg {
      background-attachment: fixed;
    }
  }
</style>
